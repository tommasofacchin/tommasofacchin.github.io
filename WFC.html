<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <link rel="stylesheet" href="style.css" />
    <link rel="stylesheet" href="styleMobile.css" />
    <link rel="stylesheet" href="styleWFC.css" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Bebas Neue">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Work Sans">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Archivo Black">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/devicons/devicon@v2.15.1/devicon.min.css">
    <script src="https://kit.fontawesome.com/98cacf8d46.js" crossorigin="anonymous"></script>
    <title>Markov WFC</title>
  </head>
  
  
  <body>
    <section class="HomePageWFC">
      
      <div class="logo">
        <a href="index.html">TF</a>
      </div>
    </section>

    <section class="IdeaWFC">
      <div class="headerTitleWFC">
        <h1>THE IDEA</h1>
      </div>
      <div class="Paragrafo">
        This project idea is to develop a procedural tilemap generator using the Wave Function Collapse (WFC) algorithm and Markov transition matrices. This approach enforces the creation of two-dimensional maps while ensuring that the selection of tiles follows specific adjacency rules. The system calculates probabilities for placing tiles based on their already defined neighbors, ensuring consistency and variation of the tilemap. The result is a functional tilemap ready to be used in games or other similar projects.</div>
    </section>
    
    <section class="ImplementationWFC">
      <div class="headerTitleWFC">
        <h1>IMPLEMENTATION</h1>
      </div>
      <div class="Paragrafo">
        The data structures I used include are: an array containing the different tiles, a matrix of ‘Cell’ objects representing the tilemap grid, the ‘Cell’ class that stores the assigned tile ID and the entropy of the cell, and four float matrices representing Markov transition matrices for each direction (top, bottom, left, right). These matrices hold the probabilities of each tile transitioning to an adjacent tile. You can see the tiles I have used and the four transition matrices in the images below.
      </div>
      <img src="images/WFC/tiles.png" class="ImageTilesWFC">
      <div class="Methods">
        <img src="images/WFC/CollapseCell.png" class="MethodImage">
        <div class="MethodDescription">	Recursive method that starts the process of collapsing of the cells, use a Coroutine and calls <code>EvaluateEntropy()</code>, <code>CollapseLowestEntropy()</code> and <code>UpdateMatrix()</code>. After that, if there are no more cells to collaps, calls the <code>plant()</code> method, otherwise calls itself.</div>
      </div>
      <div class="Methods">
        <img src="images/WFC/EvaluateEntropy.png" class="MethodImage">
        <div class="MethodDescription">Method that calls the method <code>GetEntropy()</code> for each cells of the grid, if the entropy is zero, then calls the <code>Explode()</code> method for that specific cell. Last, calls the method <code>UpdateMatrix()</code>.</div>
      </div>
      <div class="Methods">
        <img src="images/WFC/GetEntropy.png" class="MethodImage">
        <div class="MethodDescription">Method that based on the type gives as parameter returns either an integer representing the entropy of a cell, or a <code>float[]</code>  with the probabilities of collapsing a specific cell using Markov transition matrices.</div>
      </div>
      <div class="Methods">
        <img src="images/WFC/CollapseCell.png" class="MethodImage">
        <div class="MethodDescription">Method that finally collapse one of the cell with the lowest entropy, normalize the probabilities returned from the <code>GetEntropy()</code> method and choose the appropriate tile based on the normalized probability.</div>
      </div>
      <div class="Methods">
        <img src="images/WFC/Explode.png" class="MethodImage">
        <div class="MethodDescription">method that handles cases of zero entropy by resetting the surrounding area of the grid.</div>
      </div>
      <div class="Methods">
        <img src="images/WFC/UpdateMatrix.png" class="MethodImage">
        <div class="MethodDescription">Metodo that updates the tilemap based on the values of the grid.</div>
      </div>
      <div class="Methods">
        <img src="images/WFC/Plant.png" class="MethodImage">
        <div class="MethodDescription">Metodo that places prefabs to decorate the scene once the tilemap generation is completed.</div>
      </div>
    </section>
    <section class="DemonstrationWFC">
      <div class="headerTitleWFC">
        <h1>DEMONSTRATION</h1>
      </div>
      <img src="images/WFC/gif1.gif" class="GifWFC">
      <div class="Paragrafo">
        Here we can see how the algorithm works. The numbers on the cells represent either the entropy of the cell or the index of the tile placed in that position, enclosed in square brackets.
      </div>
      <img src="images/WFC/gif2.gif" class="GifWFC spacedWFC">
      <div class="Paragrafo">
        And now we can see what it actually does on the tilemap. Every tiles placed respects the probabilities we defined. After all tiles have been placed, the function <code>Plant()</code> gets called, which adds some decorations to the tilemap.  
      </div>

      <video width="1920" height="1080" class="FinalVideo" controls>
        <source src="images/WFC/FinalVideo.mp4">
      </video>

      <div class="headerTitleWFC">
        <h1>CONCLUSION</h1>
      </div>
      <div class="Paragrafo">
        The algorithm can of course be used to create way bigger tilemaps and the logic allows you add as many different tiles that you want, like water, mountains, villages and more. This might not be the most efficient way to implement procedural generation in 2D games, but I wanted to make something different using a more probabilistic approach using Markov Chains. 
      </div>

    </section>
  </body>
</html>
